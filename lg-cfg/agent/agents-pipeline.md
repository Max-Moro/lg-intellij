# Pipeline Workflow in This Project

## Important Characteristics of Subagents

**Context Isolation**: Each subagent call is a separate session. Agents do not remember previous executions. This saves tokens but requires complete instructions in each prompt.

**Reports - The Only Feedback**: The agent returns only a final report. It is impossible to ask clarifying questions after execution.

## Available Agents

### Agent: @code-integrator

You are an expensive but intelligent model. You plan architecture and write code well, but it is quite wasteful in your work to invoke many operations (Read, Edit, Glob, Grep) to make the final integration of planned changes into the final codebase. It's much more cost-effective to distribute responsibilities between you and the integrator subagent.

You don't need to use tools for editing the final code. Just write the implementation as a single Markdown document (a single detailed instruction) that a cheaper (less intelligent) AI model can use, but one that already has access to editing the codebase.

Therefore, in the final development instruction for the integrator subagent (in "Subagent System Prompt"), the main elements should be technical implementation details:
- brief business requirements;
- required changes in architecture (if needed);
- main and optimal integration points for new functionality;
- new code listings as fenced code blocks;
- description of patches (they may be informal, but sufficient for understanding by another AI model);
- **when changing public APIs** - explicit indication of ALL files using these functions/types;
- and so on;

The instruction should be written once when launching the tool for working with the @code-integrator agent. Do not duplicate this instruction in the user dialog under any circumstances.

### Agent: @code-inspector

This agent handles code quality inspection and fixes identified problems.

**What to pass to the agent:**
- **Task**: Brief description of the task (1 sentence, what is currently being worked on)
- **Recent changes**: List of modified files (from @code-integrator report)
- **Request**: Request to run inspection

### Agent: @compiler

This agent handles code compilation and fixes any problems that arise. You need to pass it a list of changed/created files with brief comments about what was changed. This is necessary so the compilation agent makes corrections thoughtfully rather than randomly deleting useful (just-added) functionality.

Comments are generated by the orchestrator based on the original change plan (for example: "added processDocument method", "updated to use new API").

### Other Agents

This project currently uses only the 3 agents mentioned above.

There is no special testing agent in the project because at this stage of development all tests are done manually by the user (visual testing).

## Types of Iterations

Depending on the complexity of the task, work on it can be done in the following ways.

### Main Iterative Cycle

#### When to Apply

- large refactorings and architecture redesign
- changes in 3 or more files
- need to completely rewrite some existing module
- usually used at the beginning of a dialog when working on a new task or feature

#### Order of Work

1. Check the sufficiency of data in the context window received from the **Listing Generator** tool. If there is insufficient data to complete the task, stop work and inform the user.
2. Perform initial planning of work on a new feature or new functional block.
3. Create a development instruction and send it to the @code-integrator agent.
4. Perform code quality check by calling the @code-inspector agent.
5. Perform compilation of the codebase by calling the @compiler agent.
6. Receive all reports from subagents and resolve their problems if any arise.
7. Create a final brief summary for the user on the results of the iteration work and send it to the dialog.
8. Complete the work and wait for user feedback and/or testing results from the user.

### Short Iterative Cycle

#### When to Apply

- targeted fixes in 2 or fewer files
- local fixing of problems and errors
- usually used when the user continues work in the dialog and gives feedback as a result of testing
- this type of iteration is necessary to conduct accelerated development

#### Order of Work

1. To speed up, make the necessary minimum fixes yourself, without using the @code-integrator agent.
2. **MANDATORY** run the @code-inspector agent to check code quality.
3. **MANDATORY** run the @compiler agent to check the build.
4. Receive all reports from subagents and resolve their problems if any arise.
5. Quickly respond to the user that the fix is ready for testing (visual check). A comprehensive summary is not required in this case.

**Important:** Even in a short cycle, you cannot skip code inspection and compilation checks. 

### General Work Rules

You must always make a decision depending on the task complexity, which type of iteration to work on it with (main or short).

In any case, you should never create final Markdown documents in the file system on your own initiative: summaries, checklists, reports on completed work and so on. All reporting at the end of iterations goes only to the dialog. If existing documentation in the repository obviously becomes outdated as a result of work on a functional block, you should not patch it yourself, just point out this nuance to the user.

Markdown documentation should be developed only if the user specifically asks for it separately.

#### Handling Escalations from Subagents

If a subagent (@code-inspector or @compiler) returns a status of "⚠️ Attention Required" or "⚠️ Manual Review Needed":

1. Read the "Remaining errors" or "Requires review" section in the subagent's report
2. Assess the complexity of the problem:
   - **Simple** (1-2 files, obvious fix) → Fix it yourself via Edit and re-run the subagent
   - **Complex** (requires refactoring, architectural changes, unclear cases with "unused" code) → Stop and inform the user
3. If the problem persists after 2 iterations of fixes → stop and inform the user

#### Using TodoWrite

TodoWrite is used **only by the orchestrator** for planning work on tasks.

Subagents **DO NOT use** TodoWrite — they work by clear instructions and immediately proceed to execution.