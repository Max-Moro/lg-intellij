package lg.intellij.services.ai

import com.intellij.openapi.components.Service
import com.intellij.openapi.components.service
import com.intellij.openapi.diagnostic.logger
import com.intellij.openapi.project.Project
import org.snakeyaml.engine.v2.api.DumpSettings
import org.snakeyaml.engine.v2.api.LoadSettings
import org.snakeyaml.engine.v2.api.lowlevel.Compose
import org.snakeyaml.engine.v2.api.lowlevel.Present
import org.snakeyaml.engine.v2.api.lowlevel.Serialize
import org.snakeyaml.engine.v2.comments.CommentLine
import org.snakeyaml.engine.v2.comments.CommentType
import org.snakeyaml.engine.v2.common.FlowStyle
import org.snakeyaml.engine.v2.common.ScalarStyle
import org.snakeyaml.engine.v2.nodes.*
import java.io.File
import java.util.Optional

/**
 * Generator for ai-interaction.sec.yaml template file.
 *
 * Collects supported modes from all registered AI providers
 * and generates/updates the canonical integration meta-section.
 *
 * Uses SnakeYAML Engine for AST-level YAML manipulation to ensure:
 * - Provider order preservation (no false git diffs on re-generation)
 * - Full metadata preservation for custom user-defined modes
 * - Proper YAML formatting with comments
 */
@Service(Service.Level.PROJECT)
class AiModesTemplateGenerator(private val project: Project) {

    private val log = logger<AiModesTemplateGenerator>()

    // ============================================
    // Data Model
    // ============================================

    /**
     * Mode metadata (without runs).
     */
    private data class ModeMeta(
        val title: String,
        val description: String? = null,
        val tags: List<String>? = null
    )

    /**
     * Parsed mode data from existing file.
     * Includes metadata and preserves provider order.
     */
    private data class ParsedModeData(
        val meta: ModeMeta,
        /** Providers in original order from file */
        val providerOrder: MutableList<String>,
        val runs: MutableMap<String, String>
    )

    // ============================================
    // Canonical Mode Definitions
    // ============================================

    private val canonicalModes = linkedMapOf(
        "ask" to ModeMeta(
            title = "Ask",
            description = "Question-answer mode"
        ),
        "agent" to ModeMeta(
            title = "Agent",
            description = "Agent mode with tools",
            tags = listOf("agent")
        ),
        "plan" to ModeMeta(
            title = "Plan",
            description = "Planning / specification mode",
            tags = listOf("agent", "plan")
        )
    )

    /**
     * Header comments for generated file.
     */
    private val fileHeaderComments = listOf(
        CommentLine(
            Optional.empty(), Optional.empty(),
            " Auto-generated by Listing Generator IDE plugins",
            CommentType.BLOCK
        ),
        CommentLine(
            Optional.empty(), Optional.empty(),
            " This file defines AI provider integration modes.",
            CommentType.BLOCK
        ),
        CommentLine(
            Optional.empty(), Optional.empty(),
            " Manual edits to unknown providers/modes will be preserved.",
            CommentType.BLOCK
        )
    )

    // ============================================
    // Public API
    // ============================================

    /**
     * Generates or updates the ai-interaction.sec.yaml file.
     *
     * Merge logic:
     * - Preserves unknown modes and providers
     * - Updates only runs for known providers
     * - Adds new modes if not present
     * - Preserves provider order from existing file
     *
     * @return Path to generated file
     * @throws IllegalStateException if project base path not found
     */
    fun generate(): String {
        val basePath = project.basePath
            ?: throw IllegalStateException("Project base path not found")

        val lgCfgDir = File(basePath, "lg-cfg")
        val filePath = File(lgCfgDir, "ai-interaction.sec.yaml")

        log.info("Generating ${filePath.absolutePath}")

        // Ensure lg-cfg directory exists
        if (!lgCfgDir.exists()) {
            lgCfgDir.mkdirs()
            log.debug("Created lg-cfg directory")
        }

        // Collect modes from all providers
        val aiService = AiIntegrationService.getInstance()
        val allModes = aiService.getAllSupportedModes()
        log.debug("Collected modes for ${allModes.size} mode types")

        // Read existing file if present
        val existingContent = if (filePath.exists()) filePath.readText() else ""

        // Merge and generate new content
        val newContent = mergeAndGenerate(existingContent, allModes)

        // Write file
        filePath.writeText(newContent)
        log.info("Written ${filePath.absolutePath}")

        return filePath.absolutePath
    }

    // ============================================
    // Merge Logic
    // ============================================

    /**
     * Merges existing content with new modes data.
     *
     * Preserves:
     * - Metadata (title, description, tags) for custom modes
     * - Provider order from existing file
     * - Unknown modes and providers
     */
    private fun mergeAndGenerate(
        existingContent: String,
        allModes: Map<String, Map<String, String>>
    ): String {
        // If no existing content, generate fresh
        if (existingContent.isBlank()) {
            return generateFresh(allModes)
        }

        // Parse existing modes with full metadata and provider order
        val existingModes = parseExistingModes(existingContent)

        // Merge: new providers override, unknown modes/providers preserved
        for ((modeId, newProviders) in allModes) {
            if (!existingModes.containsKey(modeId)) {
                // New mode — create with canonical or default metadata
                existingModes[modeId] = ParsedModeData(
                    meta = canonicalModes[modeId] ?: ModeMeta(title = modeId),
                    providerOrder = mutableListOf(),
                    runs = mutableMapOf()
                )
            }

            val modeData = existingModes[modeId] ?: continue

            // Merge providers: update runs, preserve order
            for ((providerId, runs) in newProviders) {
                modeData.runs[providerId] = runs

                // Add to order if new provider
                if (providerId !in modeData.providerOrder) {
                    modeData.providerOrder.add(providerId)
                }
            }
        }

        // Regenerate with merged data
        return generateFromParsedModes(existingModes)
    }

    // ============================================
    // AST-based Parsing
    // ============================================

    /**
     * Parses existing YAML to extract full mode data including metadata and provider order.
     */
    private fun parseExistingModes(content: String): LinkedHashMap<String, ParsedModeData> {
        val result = LinkedHashMap<String, ParsedModeData>()

        try {
            val settings = LoadSettings.builder().setParseComments(true).build()
            val compose = Compose(settings)
            val root = compose.composeString(content).orElse(null)

            if (root !is MappingNode) return result

            // Navigate: ai-interaction → mode-sets → ai-interaction → modes
            val aiInteraction = mappingGet(root, "ai-interaction") as? MappingNode ?: return result
            val modeSets = mappingGet(aiInteraction, "mode-sets") as? MappingNode ?: return result
            val aiInteractionModeSet = mappingGet(modeSets, "ai-interaction") as? MappingNode
                ?: return result
            val modes = mappingGet(aiInteractionModeSet, "modes") as? MappingNode ?: return result

            // Iterate over modes (preserving order via NodeTuple list)
            for (tuple in modes.value) {
                val modeId = scalarValue(tuple.keyNode) ?: continue
                val modeNode = tuple.valueNode as? MappingNode ?: continue

                // Extract metadata
                val title = scalarValue(mappingGet(modeNode, "title")) ?: modeId
                val description = scalarValue(mappingGet(modeNode, "description"))
                val tagsNode = mappingGet(modeNode, "tags")
                val tags = if (tagsNode is SequenceNode) {
                    tagsNode.value.mapNotNull { scalarValue(it) }
                } else {
                    null
                }

                val meta = ModeMeta(title, description, tags)

                // Extract runs preserving provider order
                val runsNode = mappingGet(modeNode, "runs") as? MappingNode
                val providerOrder = mutableListOf<String>()
                val runs = mutableMapOf<String, String>()

                if (runsNode != null) {
                    for (runTuple in runsNode.value) {
                        val providerId = scalarValue(runTuple.keyNode) ?: continue
                        val runsValue = scalarValue(runTuple.valueNode) ?: ""
                        providerOrder.add(providerId)
                        runs[providerId] = runsValue
                    }
                }

                result[modeId] = ParsedModeData(meta, providerOrder, runs)
            }
        } catch (e: Exception) {
            log.debug("Failed to parse existing file: $e")
        }

        return result
    }

    // ============================================
    // AST-based Generation
    // ============================================

    /**
     * Generates fresh YAML content from provider modes (no existing file).
     * Sorts providers alphabetically for consistent initial output.
     */
    private fun generateFresh(allModes: Map<String, Map<String, String>>): String {
        val parsedModes = LinkedHashMap<String, ParsedModeData>()
        val processedModes = mutableSetOf<String>()

        // Canonical modes first (in order)
        for (modeId in canonicalModes.keys) {
            val providers = allModes[modeId]
            if (!providers.isNullOrEmpty()) {
                // Alphabetical sort for new files only
                val sortedProviders = providers.keys.sorted()
                parsedModes[modeId] = ParsedModeData(
                    meta = canonicalModes.getValue(modeId),
                    providerOrder = sortedProviders.toMutableList(),
                    runs = providers.toMutableMap()
                )
                processedModes.add(modeId)
            }
        }

        // Non-canonical modes (also sorted)
        for ((modeId, providers) in allModes) {
            if (modeId !in processedModes && providers.isNotEmpty()) {
                val sortedProviders = providers.keys.sorted()
                parsedModes[modeId] = ParsedModeData(
                    meta = ModeMeta(title = modeId),
                    providerOrder = sortedProviders.toMutableList(),
                    runs = providers.toMutableMap()
                )
            }
        }

        return generateFromParsedModes(parsedModes)
    }

    /**
     * Generates YAML content from parsed modes data.
     * Builds YAML AST bottom-up and serializes to string.
     */
    private fun generateFromParsedModes(allModes: Map<String, ParsedModeData>): String {
        // Build modes map
        val modesTuples = mutableListOf<NodeTuple>()

        // Process canonical modes first (in order)
        val processedModes = mutableSetOf<String>()
        for (modeId in canonicalModes.keys) {
            val modeData = allModes[modeId]
            if (modeData != null && modeData.runs.isNotEmpty()) {
                modesTuples.add(NodeTuple(scalar(modeId), buildModeNode(modeId, modeData)))
                processedModes.add(modeId)
            }
        }

        // Process non-canonical modes (preserve their metadata)
        for ((modeId, modeData) in allModes) {
            if (modeId !in processedModes && modeData.runs.isNotEmpty()) {
                modesTuples.add(NodeTuple(scalar(modeId), buildModeNode(modeId, modeData)))
            }
        }

        val modesMap = MappingNode(Tag.MAP, modesTuples, FlowStyle.BLOCK)

        // Build ai-interaction mode-set
        val aiModeSetTuples = mutableListOf(
            NodeTuple(scalar("title"), scalar("AI Interaction")),
            NodeTuple(scalar("modes"), modesMap)
        )
        val aiModeSet = MappingNode(Tag.MAP, aiModeSetTuples, FlowStyle.BLOCK)

        // Build mode-sets map
        val modeSetsMap = MappingNode(
            Tag.MAP,
            mutableListOf(NodeTuple(scalar("ai-interaction"), aiModeSet)),
            FlowStyle.BLOCK
        )

        // Build ai-interaction root
        val aiRoot = MappingNode(
            Tag.MAP,
            mutableListOf(NodeTuple(scalar("mode-sets"), modeSetsMap)),
            FlowStyle.BLOCK
        )

        // Build root map
        val root = MappingNode(
            Tag.MAP,
            mutableListOf(NodeTuple(scalar("ai-interaction"), aiRoot)),
            FlowStyle.BLOCK
        )

        // Add header comments
        root.blockComments = fileHeaderComments

        return serializeToString(root)
    }

    /**
     * Builds a YAML node for a single mode.
     */
    private fun buildModeNode(modeId: String, modeData: ParsedModeData): MappingNode {
        val (meta, providerOrder, runs) = modeData

        // Use canonical metadata for canonical modes, otherwise use parsed/default
        val effectiveMeta = canonicalModes[modeId] ?: meta

        val tuples = mutableListOf<NodeTuple>()

        // title
        tuples.add(NodeTuple(scalar("title"), scalar(effectiveMeta.title)))

        // description (if present)
        effectiveMeta.description?.let {
            tuples.add(NodeTuple(scalar("description"), scalar(it)))
        }

        // tags as flow sequence (if present)
        val tags = effectiveMeta.tags
        if (!tags.isNullOrEmpty()) {
            val tagNodes = tags.map { scalar(it) }
            val tagsSeq = SequenceNode(Tag.SEQ, tagNodes, FlowStyle.FLOW)
            tuples.add(NodeTuple(scalar("tags"), tagsSeq))
        }

        // runs map (preserving provider order)
        val runsTuples = mutableListOf<NodeTuple>()
        for (providerId in providerOrder) {
            val runsValue = runs[providerId]
            if (runsValue != null) {
                runsTuples.add(NodeTuple(scalar(providerId), scalar(runsValue)))
            }
        }
        val runsMap = MappingNode(Tag.MAP, runsTuples, FlowStyle.BLOCK)
        tuples.add(NodeTuple(scalar("runs"), runsMap))

        return MappingNode(Tag.MAP, tuples, FlowStyle.BLOCK)
    }

    // ============================================
    // YAML AST Helpers
    // ============================================

    /** Creates a plain scalar node. */
    private fun scalar(value: String): ScalarNode =
        ScalarNode(Tag.STR, value, ScalarStyle.PLAIN)

    /** Extracts string value from a scalar node. */
    private fun scalarValue(node: Node?): String? =
        (node as? ScalarNode)?.value

    /** Finds a value by key in a mapping node. */
    private fun mappingGet(mapping: MappingNode, key: String): Node? =
        mapping.value.firstOrNull { scalarValue(it.keyNode) == key }?.valueNode

    /** Serializes a Node tree to YAML string with comments. */
    private fun serializeToString(root: Node): String {
        val dumpSettings = DumpSettings.builder()
            .setDumpComments(true)
            .setDefaultFlowStyle(FlowStyle.BLOCK)
            .setIndent(2)
            .setWidth(Int.MAX_VALUE)
            .build()

        val events = Serialize(dumpSettings).serializeOne(root)
        return Present(dumpSettings).emitToString(events.iterator())
    }

    companion object {
        fun getInstance(project: Project): AiModesTemplateGenerator = project.service()
    }
}
